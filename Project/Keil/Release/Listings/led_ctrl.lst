C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE LED_CTRL
OBJECT MODULE PLACED IN .\Release\Objects\led_ctrl.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\led_ctrl.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C) I
                    -NCDIR(..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\led_ctrl.lst) OBJECT(.
                    -\Release\Objects\led_ctrl.obj)

line level    source

   1          #include "include.h"
   2          #include "main.h"
   3          #include <math.h>
   4          #include <stdio.h>
   5          extern void pwm_in_handler(void);
   6          extern u16 ntc_val;
   7          extern u16 adc0_val;
   8          extern u16 adc1_val;
   9          
  10          // è¾“å‡ºå ç©ºæ¯”100%æ—¶ï¼Œå¯¹åº”çš„å ç©ºæ¯”å‚æ•°
  11          #define MAX_DUTY (6000)
  12          #define PER_DUTY (10) //
  13          #define _75_DUTY 4500 // 75%äº®åº¦
  14          #define _70_DUTY 4200
  15          #define _60_DUTY 3600
  16          #define _50_DUTY 3000
  17          #define _30_DUTY 1800
  18          
  19          #define _75_TEMP 2420              // 75æ‘„æ°åº¦å¯¹åº”çš„ADCå€¼
  20          #define _3_1V 3000                 // 3.4Vå¯¹åº”çš„ADCå€¼
  21          #define L_PWR_T (1 * 60 * 60)      // é™åŠŸç‡
  22          #define L_TEMP_PWR_T (1 * 30 * 60) // è¿‡æ¸©åŠå°æ—¶é™åŠŸç‡
  23          // #define LEVLE_PER 184              // æ¯ä¸ªæ¡£ä½å¯¹åº”çš„ADå€¼ ï¼ˆ20çº§æŒ¡ä½è°ƒèŠ‚ï¼‰
  24          // #define LEVLE_PER 92 // æ¯ä¸ªæ¡£ä½å¯¹åº”çš„ADå€¼ (40çº§æŒ¡ä½è°ƒèŠ‚)
  25          #define LEVLE_PER 23    // æ¯ä¸ªæ¡£ä½å¯¹åº”çš„ADå€¼ (160çº§æŒ¡ä½è°ƒèŠ‚)
  26          #define ADJUST_STEP 160 // è°ƒèŠ‚çº§æ•°ï¼Œä¾‹å¦‚ 20çº§ã€40çº§ã€160çº§
  27          #define DEAD_ZONE 5     // adcæ­»åŒºèŒƒå›´Â± 5
  28          
  29          bit ex_temp_en; // è¿‡æ¸©é™åŠŸç‡æ ‡å¿—ä½
  30          // #define L_PWR_T     (1*10)
  31          
  32          /* LIN æ”¹çš„åœ°æ–¹æœ‰ï¼š
  33                           å¢åŠ adc.cæ–‡ä»¶
  34                           åŠ å…¥äº†ç”µä½å™¨å€¼çš„åˆ¤æ–­                void adjust_pwm()
  35                           åŠ å…¥äº†è¿‡æ¸©é™åŠŸç‡å‡½æ•°                ex_temp_adjust_timer()
  36                                           LIN æ”¹ åŠ å…¥äº†ç”µä½å™¨ å°†æ—¶æ§æ•°å€¼æ”¹åŠ¨  void t_ctrl_timer_handl
             -er(void)
  37                                           åŠ å…¥äº†ntcå’Œç”µä½å™¨çš„è°ƒèŠ‚æ ‡å¿—ä½åˆ¤æ–­   option_fun(void)
  38                                           ä¸€å°æ—¶é™åŠŸç‡ä¸­åŠ å…¥äº†ç”µä½å™¨å€¼è½¬æ¢    l_pwr_timer_handler(v
             -oid)
  39                                           ç¼“å¯åŠ¨æ— ä¸‰åˆä¸€æ—¶å°†æœ€å¤§äº®åº¦æ”¹ä¸ºç”µä½å™¨çš„å€¼   void led_p
             -wr_on(void)
  40          */
  41          typedef struct
  42          {
  43              u32 t;    // è®¡æ—¶å™¨
  44              u8 level; // æ—¶ç©ºåˆ—è¡¨æ‰§è¡Œçš„å“ªä¸€ä¸ªæ—¶é—´æ®µ
  45              u8 list;  // æ—¶æ§åˆ—è¡¨ï¼Œ5ä¸ªåˆ—è¡¨
  46              u8 en;    // ä½¿èƒ½
  47          } t_ctrl_t;   // æ—¶æ§ç»“æ„ä½“
  48          
  49          typedef struct
  50          {
C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 2   

  51              u8 en;
  52              u8 act; // åŠ¨ä½œï¼Œæ‰§è¡Œé™åŠŸç‡åŠ¨ä½œï¼š1
  53              u32 t;  // ç§’
  54          
  55          } l_pwr_t; // é™åŠŸç‡ç»“æ„ä½“
  56          
  57          typedef struct
  58          {
  59              u8 en;
  60          } _3_1_t; // ä¸‰åˆä¸€ç»“æ„ä½“
  61          
  62          u8 cap_10ms_cnt; // 10msè·å–ä¸€æ¬¡æ•è·å ç©ºæ¯”
  63          u8 pwr_on_cnt;
  64          u16 c_duty = 0;      // å½“å‰è®¾ç½®çš„å ç©ºæ¯”
  65          u32 pwm_in_duty = 0; // ä¸‰åˆä¸€PWMè¾“å…¥çš„å ç©ºæ¯”
  66          u32 pwm_in_duty_xuwei = 0;
  67          u32 ex_pwm_in_duty = 0;
  68          u16 ex_max_duty = 0;
  69          u16 max_duty = 6000; // å¯è°ƒçš„æœ€å¤§å ç©ºæ¯”
  70          t_ctrl_t t_ctrl;
  71          l_pwr_t l_pwr;
  72          _3_1_t _3_1;
  73          bit dly_pwr_on = 0;
  74          u8 dly_pwr_on_cnt = 0;
  75          bit is_pwr_down = 0; // 1ï¼šæ­£åœ¨é™åŠŸç‡ï¼Œè°ƒç”¨ç¼“å‡ç¼“é™é€»è¾‘
  76          bit adjust_en;
  77          // æ—¶æ§æ¨¡å¼0ï¼š100%6H 50%6H 0%
  78          // æ—¶æ§æ¨¡å¼1ï¼š100%4H 50%8H 0%
  79          // æ—¶æ§æ¨¡å¼2ï¼š100%5H 70%3H 50%4H 0%
  80          // æ—¶æ§æ¨¡å¼3ï¼š100%4H 70%4H 50%4H 0%
  81          // æ—¶æ§æ¨¡å¼4ï¼š100%4H 60%2H 30%3H 60%2H 100%1H 0%
  82          void flag_init();
  83          typedef struct
  84          {
  85              u16 b; // å½“å‰äº®åº¦
  86              u8 t;  // å½“å‰äº®åº¦ä¿æŒæ—¶é—´,255æ—¶æ§ç»“æŸ
  87          } t_ctrl_list_t;
  88          
  89          t_ctrl_list_t t_ctrl_lis_0[3] =
  90              {
  91                  {MAX_DUTY, 6}, {_50_DUTY, 6}, {0, 255} // 6 6
  92          };
  93          
  94          t_ctrl_list_t code t_ctrl_lis_1[3] =
  95              {
  96                  {MAX_DUTY, 4}, {_50_DUTY, 8}, {0, 255}};
  97          
  98          t_ctrl_list_t code t_ctrl_lis_2[4] =
  99              {
 100                  {MAX_DUTY, 5}, {_70_DUTY, 3}, {_50_DUTY, 4}, {0, 255} // 534
 101          };
 102          
 103          t_ctrl_list_t code t_ctrl_lis_3[4] =
 104              {
 105                  {MAX_DUTY, 4}, {_70_DUTY, 4}, {_50_DUTY, 4}, {0, 255} // 444
 106          };
 107          
 108          t_ctrl_list_t code t_ctrl_lis_4[6] =
 109              {
 110                  {MAX_DUTY, 4}, {_60_DUTY, 2}, {_30_DUTY, 3}, {_60_DUTY, 2}, {MAX_DUTY, 1}, {0, 255} // 42321
 111          };
 112          
C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 3   

 113          t_ctrl_list_t *p_list;
 114          
 115          extern u16 cap0_val;
 116          extern u16 cap1_val;
 117          
 118          extern void led_pwr_on(void);
 119          extern void cmp_duty(void);
 120          extern void led_plus(void);
 121          extern void led_sub(void);
 122          extern void cal_pwm_in_duty(void);
 123          
 124          extern u16 adjust_val; // ç”µä½å™¨çš„ADCå€¼ 0~3686---->60%~100%---->3600~6000
 125          u16 ajust_duty;
 126          // 20æ¡£ç”µä½å™¨è°ƒèŠ‚pwm   60%-62%-64%-66%- 68%-70%-72%-74%-76%6-7896-80%--82. 5%-85%-87.5%-90%-92%-94%-
             -96%-98%-100%
 127          // ä¿®æ”¹ä¸º40æ¡£ç”µä½å™¨è°ƒèŠ‚ pwm
 128          void adjust_pwm()
 129          {
 130   1          static u16 last_level = 0xFF;           // è®°å½•ä¹‹å‰çš„æŒ¡ä½
 131   1          u16 cur_level = adjust_val / LEVLE_PER; // è®¡ç®—å½“å‰æŒ¡ä½
 132   1      
 133   1          if (adjust_en == 1)
 134   1          {
 135   2      #if 0 // 20çº§æŒ¡ä½è°ƒèŠ‚ï¼š
                      if (adjust_val > 3680) // 4.5Vå¯¹åº”çš„ADå€¼
                      {
                          ajust_duty = 6000;
                      }
                      if (0 < adjust_val && adjust_val < LEVLE_PER)
                      {
                          ajust_duty = 3600;
                      }
                      else if (LEVLE_PER < adjust_val && adjust_val < LEVLE_PER * 2)
                      {
                          ajust_duty = 3720;
                      }
                      else if (2 * LEVLE_PER < adjust_val && adjust_val < LEVLE_PER * 3)
                      {
                          ajust_duty = 3840;
                      }
                      else if (3 * LEVLE_PER < adjust_val && adjust_val < LEVLE_PER * 4)
                      {
                          ajust_duty = 3960;
                      }
                      else if (4 * LEVLE_PER < adjust_val && adjust_val < LEVLE_PER * 5)
                      {
                          ajust_duty = 4080;
                      }
                      else if (5 * LEVLE_PER < adjust_val && adjust_val < LEVLE_PER * 6)
                      {
                          ajust_duty = 4200;
                      }
                      else if (6 * LEVLE_PER < adjust_val && adjust_val < LEVLE_PER * 7)
                      {
                          ajust_duty = 4320;
                      }
                      else if (7 * LEVLE_PER < adjust_val && adjust_val < LEVLE_PER * 8)
                      {
                          ajust_duty = 4440;
                      }
                      else if (8 * LEVLE_PER < adjust_val && adjust_val < LEVLE_PER * 9)
                      {
C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 4   

                          ajust_duty = 4560;
                      }
                      else if (9 * LEVLE_PER < adjust_val && adjust_val < LEVLE_PER * 10)
                      {
                          ajust_duty = 4680;
                      }
                      else if (10 * LEVLE_PER < adjust_val && adjust_val < LEVLE_PER * 11)
                      {
                          ajust_duty = 4800;
                      }
                      else if (11 * LEVLE_PER < adjust_val && adjust_val < LEVLE_PER * 12)
                      {
                          ajust_duty = 4950;
                      }
                      else if (12 * LEVLE_PER < adjust_val && adjust_val < LEVLE_PER * 13)
                      {
                          ajust_duty = 5100;
                      }
                      else if (13 * LEVLE_PER < adjust_val && adjust_val < LEVLE_PER * 14)
                      {
                          ajust_duty = 5250;
                      }
                      else if (14 * LEVLE_PER < adjust_val && adjust_val < LEVLE_PER * 15)
                      {
                          ajust_duty = 5400;
                      }
                      else if (15 * LEVLE_PER < adjust_val && adjust_val < LEVLE_PER * 16)
                      {
                          ajust_duty = 5520;
                      }
                      else if (16 * LEVLE_PER < adjust_val && adjust_val < LEVLE_PER * 17)
                      {
                          ajust_duty = 5640;
                      }
                      else if (17 * LEVLE_PER < adjust_val && adjust_val < LEVLE_PER * 18)
                      {
                          ajust_duty = 5760;
                      }
                      else if (18 * LEVLE_PER < adjust_val && adjust_val < LEVLE_PER * 19)
                      {
                          ajust_duty = 5880;
                      }
                      else if (19 * LEVLE_PER < adjust_val && adjust_val < LEVLE_PER * 20)
                      {
                          ajust_duty = 6000;
                      }
                      // ajust_duty=5760;
              #endif
 222   2      
 223   2              if (adjust_val > 3680) // è¶…å‡ºäº†4.5Vå¯¹åº”çš„ADå€¼
 224   2              {
 225   3                  ajust_duty = 6000;
 226   3                  last_level = cur_level;
 227   3                  return;
 228   3              }
 229   2      
 230   2              if (0 == cur_level) // æœ€å°æŒ¡ä½
 231   2              {
 232   3                  ajust_duty = 3600;
 233   3                  last_level = cur_level;
 234   3                  return;
 235   3              }
C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 5   

 236   2      
 237   2              if (cur_level >= ADJUST_STEP) // æœ€å¤§æŒ¡ä½
 238   2              {
 239   3                  ajust_duty = 6000;
 240   3                  last_level = cur_level;
 241   3                  return;
 242   3              }
 243   2      
 244   2              if (last_level == cur_level)
 245   2              {
 246   3                  // ä¹‹å‰çš„æŒ¡ä½å’Œå½“å‰è®¡ç®—å¾—å‡ºçš„æŒ¡ä½ä¸€æ ·ï¼Œä¸è°ƒèŠ‚
 247   3                  return;
 248   3              }
 249   2      
 250   2              ajust_duty = 3600 + cur_level * ((6000 - 3600) / ADJUST_STEP);
 251   2              last_level = cur_level;
 252   2          }
 253   1      }
 254          
 255          //
 256          u16 ex_temp_t = 0;
 257          u8 ex_temp_cnt = 0; // è¿‡æ¸©é™åŠŸç‡å¤„ç†æ¬¡æ•°ï¼Œç¬¬ä¸€æ¬¡é™åˆ°90% ç¬¬äºŒæ¬¡80%-----
 258          u8 ex_temp_state = 1;
 259          
 260          #if 0 // æ­§ä¹‰ è¿‡æ¸©é™åŠŸç‡æ˜¯å¦é™ä¸ºå½“å‰å€¼çš„90%
              
              void ex_temp_adjust_timer()//è¿‡æ¸©é™åŠŸç‡å®šæ—¶å¤„ç†
              {
                      if(ex_temp_en==1)//åˆ¤æ–­è¿‡æ¸©é™åŠŸç‡æ ‡å¿—
                      {
                              if(adjust_en==0)//åˆ¤æ–­ç”µä½å™¨
                                      {
                                              if(ntc_val<_75_TEMP&&ex_temp_state==1)//åŠå°æ—¶å¤„ç†ä¸€æ¬¡ ADå€¼è¶Šå° æ¸©åº¦è¶Šé«˜
                                              {
                                                      if(pwm_in_duty>(6000*ex_temp_cnt/10))
                                                      {
                                                              max_duty=6000*ex_temp_cnt/10;//ç¬¬ä¸€æ¬¡é™åˆ°90%ï¼Œä¹‹åæ¯æ¬¡å°†10% 10%å¯¹åº”600
                                                              ex_temp_state=0;//å¤„ç†å®Œæˆ åŠå°æ—¶åå†å¼€å¯
                                                      }
                                                      else
                                                      {
                                                              ex_temp_cnt--;
                                                              ex_temp_state=1;
                                                      }
                                              }
                                              ex_temp_t++;
                                              if(ex_temp_t==L_TEMP_PWR_T)
                                              {
                                                      ex_temp_t=0;//åŠå°æ—¶è®¡æ•°æ¸…é›¶
                                                      ex_temp_state=1;
                                                      ex_temp_cnt--;//æ¯åŠå°æ—¶è®¡æ•°ä¸€æ¬¡
                                              }
                                              if(ntc_val>_75_TEMP)//åˆ¤æ–­æ¸©åº¦æ˜¯å¦ä¸‹é™åˆ°75ä»¥ä¸‹
                                              {
                                                      ex_temp_cnt=9;
                                              }
                                      }
                                      if(adjust_en==1)//åˆ¤æ–­ç”µä½å™¨
                                      {
                                              if(ntc_val<_75_TEMP&&ex_temp_state==1)//åŠå°æ—¶å¤„ç†ä¸€æ¬¡ ADå€¼è¶Šå° æ¸©åº¦è¶Šé«˜
                                              {
                                                      if(pwm_in_duty>(ajust_duty*ex_temp_cnt/10))
C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 6   

                                                      {
                                                              max_duty=ajust_duty*ex_temp_cnt/10;//ç¬¬ä¸€æ¬¡é™åˆ°90%ï¼Œä¹‹å80% 70% 
                                                              ex_temp_state=0;//å¤„ç†å®Œæˆ åŠå°æ—¶åå†å¼€å¯
                                                      }
                                                      else
                                                      {
                                                              ex_temp_cnt--;
                                                              ex_temp_state=1;
                                                      }
                                              }
                                              ex_temp_t++;
                                              if(ex_temp_t==L_TEMP_PWR_T)
                                              {
                                                      ex_temp_t=0;//åŠå°æ—¶è®¡æ•°æ¸…é›¶
                                                      ex_temp_state=1;
                                                      ex_temp_cnt--;//æ¯åŠå°æ—¶è®¡æ•°ä¸€æ¬¡
                                              }
                                              if(ntc_val>_75_TEMP)//åˆ¤æ–­æ¸©åº¦æ˜¯å¦ä¸‹é™åˆ°75ä»¥ä¸‹
                                              {
                                                      ex_temp_cnt=9;
                                              }
                                      }
                      }
              }
              #endif
 323          u16 pwm_save[10] = 0;
 324          u16 ex_duty = 0;
 325          bit extemp_flag = 0;
 326          bit extemp_tctrl_flag = 0;
 327          void ex_temp_adjust_timer() // è¿‡æ¸©é™åŠŸç‡ å®šæ—¶åˆ¤æ–­ æ¯ç§’æ‰§è¡Œä¸€æ¬¡
 328          {
 329   1          // printf("ntc_val=%d  ex_temp_cnt=%d   ex_temp_t=%d  \r\n",(int)pwm_in_duty,(int)c_duty,(int)ex_temp_
             -t);
 330   1          if (ex_temp_en == 1 && t_ctrl.en == 0)
 331   1          {
 332   2              // ntc_val=adjust_val;
 333   2              if (extemp_tctrl_flag == 1)
 334   2              {
 335   3                  pwm_save[0] = max_duty;
 336   3                  ex_temp_cnt = 0;
 337   3                  extemp_tctrl_flag = 0;
 338   3              }
 339   2              if (ntc_val < _3_1V && ex_temp_state == 1) // åŠå°æ—¶å¤„ç†ä¸€æ¬¡ ADå€¼è¶Šå° æ¸©åº¦è¶Šé«˜
 340   2              {
 341   3                  pwm_save[ex_temp_cnt] = pwm_in_duty; // ç”¨æ•°ç»„å­˜ä½ç¬¬ä¸€ä¸ªå€¼
 342   3      
 343   3                  ex_duty = pwm_save[0] - (pwm_save[0] / 10 * (ex_temp_cnt + 1)); // ç¬¬ä¸€æ¬¡é™åˆ°90%ï¼Œä¹‹å
             -æ¯æ¬¡å°†10%
 344   3                  ex_temp_state = 0;                                              // å¤„ç†å®Œæˆ åŠå°æ—¶åå†
             -å¼€å¯
 345   3                  ex_temp_t = 0;
 346   3      
 347   3                  max_duty = ex_duty;
 348   3                  ex_temp_cnt++;
 349   3                  if (ex_temp_cnt > 9)
 350   3                  {
 351   4                      max_duty = 0;
 352   4                  }
 353   3                  extemp_flag = 1;
 354   3              }
 355   2              if (ntc_val > _3_1V) // æ¸©åº¦é™ä¸‹æ¥å ä¸å¹²é¢„æœ€å¤§å€¼ å¹¶ä¸”è®¡æ•°ç½®0 ä¸‹æ¬¡è¿‡æ¸©å†ä»9
             -0%å¼€å§‹
C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 7   

 356   2              {
 357   3                  ex_temp_cnt = 0;
 358   3                  if (extemp_flag == 1 && ex_temp_state == 1)
 359   3                  {
 360   4                      if (extemp_tctrl_flag == 0)
 361   4                      {
 362   5                          if (adjust_en == 1)
 363   5                          {
 364   6                              if (_3_1.en == 1)
 365   6                                  max_duty = pwm_in_duty_xuwei;
 366   6                              else
 367   6                                  max_duty = ajust_duty;
 368   6                          }
 369   5                          if (adjust_en == 0)
 370   5                          {
 371   6                              if (_3_1.en == 1)
 372   6                                  max_duty = ex_pwm_in_duty;
 373   6                              else
 374   6                                  max_duty = pwm_save[0];
 375   6                          }
 376   5                          if (P00 == 0)
 377   5                          {
 378   6                              if (max_duty > ex_max_duty)
 379   6                              {
 380   7                                  max_duty = ex_max_duty;
 381   7                              }
 382   6                          }
 383   5                      }
 384   4                      if (extemp_tctrl_flag == 1)
 385   4                      {
 386   5                          extemp_tctrl_flag = 0;
 387   5                          extemp_flag = 0;
 388   5                          ex_temp_cnt = 0;
 389   5                          return;
 390   5                      }
 391   4                  }
 392   3              }
 393   2              ex_temp_t++;
 394   2              if (ex_temp_t == L_TEMP_PWR_T)
 395   2              {
 396   3                  ex_temp_t = 0; // åŠå°æ—¶è®¡æ•°æ¸…é›¶
 397   3                  ex_temp_state = 1;
 398   3                  // extemp_flag=0;
 399   3              }
 400   2      
 401   2              //    if(extemp_tctrl_flag==1)
 402   2              //                      {
 403   2              //                              pwm_save[0]=max_duty;
 404   2              //                      }
 405   2          }
 406   1          is_pwr_down = 1;
 407   1          // printf("ex_temp_state=%d\r\n",(int)ex_temp_state);
 408   1          // printf("pwm_in_duty= %d  t= %d  ajust_duty=%d  c_duty=%d adjust_val=%d pwm_save[0]=%d\r\n", (int)pw
             -m_in_duty,(int)t_ctrl.t,(int)ajust_duty,(int)c_duty,(int)adjust_val,(int)pwm_save[0]);
 409   1      }
 410          
 411          void set_pwm_duty(void)
 412          {
 413   1          u16 duty_tmp;
 414   1          //    if(c_duty != 0)
 415   1          {
 416   2      
C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 8   

 417   2              duty_tmp = MAX_DUTY - c_duty;
 418   2              // c_duty = 10;
 419   2              STMR0_CMPAH = STMR_CMPA_VAL_H(((c_duty) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
 420   2              STMR0_CMPAL = STMR_CMPA_VAL_L(((c_duty) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
 421   2              STMR_LOADEN |= STMR_0_LOAD_EN(0x1);                    // è‡ªåŠ¨è£…è½½ä½¿èƒ½
 422   2          }
 423   1          //    else
 424   1          {
 425   2          }
 426   1      
 427   1          // TMR2_PWMH  = TMR_PWM_VAL_H((duty_tmp >> 8) & 0xFF);                      // å ç©ºæ¯”è®¾ç½®å€¼
 428   1          // TMR2_PWML  = TMR_PWM_VAL_L((duty_tmp >> 0) & 0xFF);
 429   1      }
 430          
 431          u8 adjust_ms = 0;
 432          void cap_timer(void)
 433          {
 434   1          if (cap_10ms_cnt < 10)
 435   1          {
 436   2              cap_10ms_cnt++;
 437   2          }
 438   1          pwr_on_cnt++;
 439   1          adjust_ms++;
 440   1      }
 441          
 442          // æ”¾åœ¨while,æ²¡10msè·å–ä¸€æ¬¡PWMå ç©ºæ¯”
 443          // è¿ç»­è·å–5æ¬¡ï¼Œå ç©ºæ¯”ç¨³å®šæ‰è¾“å‡º
 444          u16 duty_buff[5];
 445          u8 duty_cnt = 0;
 446          // ä¸Šç”µé‡‡æ ·5æ¬¡å®Œæˆæ ‡å¿—ä½
 447          u8 simple_over = 0;
 448          // æ”¾ä¸»å¾ªç¯
 449          void get_duty(void)
 450          {
 451   1          // 10msè·å–ä¸€æ¬¡ï¼š
 452   1          if (cap_10ms_cnt >= 10)
 453   1          {
 454   2              cap_10ms_cnt = 0;
 455   2              if (_3_1.en == 1) // ä¸‰åˆä¸€åŠŸèƒ½å¼€å¯æ‰è°ƒå…‰
 456   2              {
 457   3                  // éä¸‰åˆä¸€ä¸ä¼šæ›´æ–°pwm_in_duty
 458   3                  cal_pwm_in_duty();
 459   3              }
 460   2      
 461   2              // å¤„ç†é™åŠŸç‡ï¼Œæ—¶æ§æ¿€æ´»ï¼Œé™åˆ¶å¯è°ƒçš„å ç©ºæ¯”èŒƒå›´
 462   2              // å»¶æ—¶å¼€æœºæ¨¡å¼ï¼Œå¼ºåˆ¶pwm_in_duty=0
 463   2      
 464   2              pwm_in_handler();
 465   2              cmp_duty();
 466   2          }
 467   1      
 468   1          // å¤„äºè°ƒå…‰æ¨¡å¼ï¼Œ led_state == LED_ADJ_P æˆ–è€… led_state == LED_ADJ_Sï¼Œæ‰ä¼šè¿›å…¥ï¼š
 469   1          if (adjust_ms == 3)
 470   1          {
 471   2              adjust_ms = 0;
 472   2              led_plus();
 473   2              led_sub();
 474   2          }
 475   1      
 476   1          led_pwr_on();
 477   1      }
 478          
C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 9   

 479          // è®¡ç®—ä¸‰åˆä¸€çš„å ç©ºæ¯”,å‚¨å­˜pwm_in_duty
 480          void cal_pwm_in_duty(void)
 481          {
 482   1          u8 i;
 483   1          if (cap1_val == 0 && cap0_val == 0)
 484   1          {
 485   2              if (P14 == 0)
 486   2              {
 487   3                  // å ç©ºæ¯” 0
 488   3                  pwm_in_duty = 0;
 489   3              }
 490   2              if (P14 == 1)
 491   2              {
 492   3                  pwm_in_duty = 6000;
 493   3              }
 494   2          }
 495   1          else
 496   1          {
 497   2              pwm_in_duty = (u32)MAX_DUTY * (cap1_val + 1);
 498   2              pwm_in_duty = pwm_in_duty / (cap0_val + 1);
 499   2          }
 500   1      
 501   1          cap1_val = 0;
 502   1          cap0_val = 0;
 503   1          duty_buff[duty_cnt] = pwm_in_duty;
 504   1          duty_cnt++;
 505   1          if (duty_cnt == 5)
 506   1          {
 507   2              simple_over = 1;
 508   2              duty_cnt = 0;
 509   2          }
 510   1          if (simple_over == 1)
 511   1          {
 512   2              pwm_in_duty = 0;
 513   2              for (i = 0; i < 5; i++)
 514   2              {
 515   3                  pwm_in_duty += duty_buff[i];
 516   3              }
 517   2              // æ±‚å¹³å‡
 518   2              pwm_in_duty = pwm_in_duty / 5;
 519   2          }
 520   1          // printf("3_1_pwm_in_duty= %d    c_duty=%d\r\n",(int)pwm_in_duty,(int)c_duty);
 521   1          // pwm_in_duty=5000;
 522   1      
 523   1          if (adjust_en == 1)
 524   1          {
 525   2              pwm_in_duty_xuwei = pwm_in_duty * ajust_duty / 6000;
 526   2              pwm_in_duty = pwm_in_duty_xuwei;
 527   2          }
 528   1          ex_pwm_in_duty = pwm_in_duty;
 529   1      }
 530          
 531          // å¯¹æ¯”å½“å‰çš„dutyæ˜¯å¦å‘ç”Ÿå˜åŒ–
 532          void cmp_duty(void)
 533          {
 534   1          if (led_state == LED_PWR_ON)
 535   1              return;
 536   1      
 537   1          if (pwm_in_duty > 10)
 538   1          {
 539   2              if ((pwm_in_duty - 10) > c_duty)
 540   2              {
C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 10  

 541   3                  led_state = LED_ADJ_P;
 542   3              }
 543   2              if ((pwm_in_duty + 10) < c_duty)
 544   2              {
 545   3                  led_state = LED_ADJ_S;
 546   3              }
 547   2          }
 548   1          else
 549   1          {
 550   2              if (pwm_in_duty > c_duty)
 551   2              {
 552   3                  led_state = LED_ADJ_P;
 553   3              }
 554   2              if (pwm_in_duty < c_duty)
 555   2              {
 556   3                  led_state = LED_ADJ_S;
 557   3              }
 558   2          }
 559   1      }
 560          
 561          // ä¸Šç”µledç¼“æ…¢å¯åŠ¨
 562          // æ¯10msæ‰§è¡Œä¸€æ¬¡ï¼Œc_dutyæ¯æ¬¡+30
 563          float gamma = 1;
 564          void debug_putchar(u8 uart_data);
 565          
 566          // float step = 90;
 567          float step = 70;
 568          
 569          float mi;  // å¹‚
 570          float rus; // 10çš„å¹‚æ¬¡æ–¹
 571          float r_ms = 0;
 572          u16 rus_duty; // æ”¾å¤§60å€
 573          
 574          // 1msè°ƒç”¨ä¸€æ¬¡     LIN æ”¹ åŠ å…¥ç”µä½å™¨åˆ¤æ–­
 575          void led_pwr_on(void)
 576          {
 577   1      
 578   1          // ä¸Šç”µæ¨¡å¼ï¼Œç¦æ­¢è°ƒå…‰ï¼Œå¹¶ä¸”ä¸Šç”µåé‡‡æ ·äº†5æ¬¡
 579   1          if (led_state == LED_PWR_ON && simple_over == 1)
 580   1          {
 581   2              // æ²¡æœ‰ç”µä½å™¨æ—¶
 582   2              // æ²¡æœ‰ä¸‰åˆä¸€åŠŸèƒ½ï¼Œä¸Šç”µé»˜è®¤æœ€å¤§å ç©ºæ¯”
 583   2              // æœ‰ä¸‰åˆä¸€åŠŸèƒ½ï¼ŒæŒ‰é‡‡ç”¨çš„å ç©ºæ¯”è°ƒå…‰
 584   2              if (adjust_en == 0)
 585   2              {
 586   3                  if (_3_1.en == 0)
 587   3                  {
 588   4                      pwm_in_duty = max_duty;
 589   4                  }
 590   3      
 591   3      #if 0
                          r_ms = step / 12;
                          if (r_ms < 1)
                              r_ms = 10;
                          if (pwr_on_cnt < r_ms)
                              return; // æ—¶é—´æœªåˆ°ä¸è°ƒæ•´
              
                          pwr_on_cnt = 0;
                          if (c_duty < pwm_in_duty)
                          {
                              mi = (step - 1) / (253 / 3) - 1;
                              step += 0.5;
C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 11  

                              c_duty = pow(5, mi) * 60;
                          }
              #endif
 606   3      
 607   3                  /*
 608   3                      è°ƒèŠ‚èŒƒå›´ï¼š0 ~ pwm_in_dutyï¼Œåˆ†æˆ 60sï¼Œ60 * 1000 ms
 609   3                      é‚£ä¹ˆæ¯msè°ƒèŠ‚ pwm_in_duty / (60 * 1000)
 610   3      
 611   3                      å¦‚æœè¦åœ¨ 0 ~ 0.75 * pwm_in_duty çš„èŒƒå›´å†…ï¼Œåˆ†æˆ 45s
 612   3                      0.75 * pwm_in_duty ~ pwm_in_duty çš„èŒƒå›´å†…ï¼Œåˆ†æˆ 15s
 613   3                      é‚£ä¹ˆæ¯ ms è°ƒèŠ‚
 614   3      
 615   3                      è°ƒèŠ‚æ—¶é—´æœ€é•¿60sï¼Œå¦‚æœpwm_in_duty < 6000ï¼Œè°ƒèŠ‚æ—¶é—´ä¼šæœ‰ç¼©çŸ­
 616   3                      0 ~ 3000çš„å ç©ºæ¯”å€¼ï¼Œè°ƒèŠ‚æ—¶é—´ä¸º 45s ï¼Œæ¯msè°ƒèŠ‚çº¦ 0.067 çš„å ç©ºæ¯”å€¼
 617   3                      3000 ~ 6000çš„å ç©ºæ¯”å€¼ï¼Œè°ƒèŠ‚æ—¶é—´ä¸º 15sï¼Œæ¯msè°ƒèŠ‚çº¦ 0.2 çš„å ç©ºæ¯”å€¼
 618   3                  */
 619   3                  if (adjust_pwm_during_pwr_on >= 1)
 620   3                  {
 621   4                      adjust_pwm_during_pwr_on = 0;
 622   4      
 623   4                      if (c_duty <= (MAX_DUTY / 2)) // 0 ~ 50%çš„å ç©ºæ¯”å€¼
 624   4                      {
 625   5                          pwr_on_step += (double)0.067;
 626   5                      }
 627   4                      else // 50% ~ 100%çš„å ç©ºæ¯”å€¼
 628   4                      {
 629   5                          pwr_on_step += (double)0.2;
 630   5                      }
 631   4      
 632   4                      c_duty = (u16)pwr_on_step;
 633   4                  }
 634   3      
 635   3                  if (c_duty >= pwm_in_duty)
 636   3                  {
 637   4                      c_duty = pwm_in_duty;
 638   4                      pwr_on_step = 0;      // é€€å‡ºå¼€æœºç¼“å¯åŠ¨å‰ï¼Œæ¸…ç©ºæ­¥é•¿
 639   4                      led_state = LED_NULL; // é€€å‡ºå¼€æœºç¼“å¯åŠ¨
 640   4                      // printf("pwr on end\n");
 641   4                  }
 642   3      
 643   3                  set_pwm_duty();
 644   3              }
 645   2      
 646   2              if (adjust_en == 1) // æœ‰æ²¡æœ‰ä¸‰åˆä¸€åŠŸèƒ½ï¼Œä¸Šç”µéƒ½é»˜è®¤ç”µä½å™¨çš„æœ€å¤§å ç©ºæ¯”
 647   2              {
 648   3                  if (_3_1.en == 0)
 649   3                  {
 650   4                      pwm_in_duty = ajust_duty;
 651   4                  }
 652   3      
 653   3                  if (_3_1.en == 1)
 654   3                  {
 655   4                      pwm_in_duty = pwm_in_duty_xuwei;
 656   4                  }
 657   3      
 658   3      #if 0
                          r_ms = step / 12;
                          if (r_ms < 1)
                              r_ms = 10;
              
                          if (pwr_on_cnt < r_ms)
                              return; // æ—¶é—´æœªåˆ°ä¸è°ƒæ•´
C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 12  

              
                          pwr_on_cnt = 0;
                          if (c_duty < pwm_in_duty)
                          {
                              mi = (step - 1) / (253 / 3) - 1;
                              step += 0.5;
                              c_duty = pow(5, mi) * 60;
                          }
              #endif
 674   3      
 675   3                  /*
 676   3                       è°ƒèŠ‚èŒƒå›´ï¼š0 ~ pwm_in_dutyï¼Œåˆ†æˆ 60sï¼Œ60 * 1000 ms
 677   3                       é‚£ä¹ˆæ¯msè°ƒèŠ‚ pwm_in_duty / (60 * 1000)
 678   3      
 679   3                       å¦‚æœè¦åœ¨ 0 ~ 0.75 * pwm_in_duty çš„èŒƒå›´å†…ï¼Œåˆ†æˆ 45s
 680   3                       0.75 * pwm_in_duty ~ pwm_in_duty çš„èŒƒå›´å†…ï¼Œåˆ†æˆ 15s
 681   3                       é‚£ä¹ˆæ¯ ms è°ƒèŠ‚
 682   3      
 683   3                       è°ƒèŠ‚æ—¶é—´æœ€é•¿60sï¼Œå¦‚æœpwm_in_duty < 6000ï¼Œè°ƒèŠ‚æ—¶é—´ä¼šæœ‰ç¼©çŸ­
 684   3                       0 ~ 3000çš„å ç©ºæ¯”å€¼ï¼Œè°ƒèŠ‚æ—¶é—´ä¸º 45s ï¼Œæ¯msè°ƒèŠ‚çº¦ 0.067 çš„å ç©ºæ¯”å€¼
 685   3                       3000 ~ 6000çš„å ç©ºæ¯”å€¼ï¼Œè°ƒèŠ‚æ—¶é—´ä¸º 15sï¼Œæ¯msè°ƒèŠ‚çº¦ 0.2 çš„å ç©ºæ¯”å€¼
 686   3                   */
 687   3                  if (adjust_pwm_during_pwr_on >= 1)
 688   3                  {
 689   4                      adjust_pwm_during_pwr_on = 0;
 690   4      
 691   4                      if (c_duty <= (MAX_DUTY / 2)) // 0 ~ 50%çš„å ç©ºæ¯”å€¼
 692   4                      {
 693   5                          pwr_on_step += (double)0.067;
 694   5                      }
 695   4                      else // 50% ~ 100%çš„å ç©ºæ¯”å€¼
 696   4                      {
 697   5                          pwr_on_step += (double)0.2;
 698   5                      }
 699   4      
 700   4                      c_duty = (u16)pwr_on_step;
 701   4                  }
 702   3      
 703   3                  // é˜²æ­¢å ç©ºæ¯”æº¢å‡ºï¼š
 704   3                  if (c_duty >= pwm_in_duty)
 705   3                  {
 706   4                      c_duty = pwm_in_duty;
 707   4                      pwr_on_step = 0;      // é€€å‡ºå¼€æœºç¼“å¯åŠ¨å‰ï¼Œæ¸…ç©ºæ­¥é•¿
 708   4                      led_state = LED_NULL; // é€€å‡ºå¼€æœºç¼“å¯åŠ¨
 709   4                      // printf("pwr on end\n");
 710   4                  }
 711   3      
 712   3                  set_pwm_duty();
 713   3              }
 714   2          }
 715   1      
 716   1          // printf("pwm_in_duty= %d   t= %d    t_ctrl.level=%d    c_duty=%d\r\n", (int)pwm_in_duty,(int)t_ctrl.
             -t,(int)ajust_duty,(int)c_duty);
 717   1      
 718   1          // printf("test =========================\n"); // æµ‹è¯•å‡½æ•°è¿›å…¥æ—¶é—´ï¼Œæ¯æ¬¡ä¸»å¾ªç¯éƒ½ä¼šè¿›å
             -…¥ï¼Œå‡ ä¹æ²¡æœ‰æ—¶é—´é—´éš”
 719   1      
 720   1          // {
 721   1          //     // æ¯éš”ä¸€æ®µæ—¶é—´ï¼Œæ‰“å°ä¸€æ¬¡ c_dutyï¼š
 722   1          //     if (user_debug_ms_cnt >= 100)
 723   1          //     {
 724   1          //         printf("c_duty = %u\n", c_duty);
C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 13  

 725   1          //         user_debug_ms_cnt = 0;
 726   1          //     }
 727   1          // }
 728   1      }
 729          
 730          void led_plus(void)
 731          {
 732   1          if (led_state != LED_ADJ_P)
 733   1              return;
 734   1          if (c_duty < pwm_in_duty)
 735   1          {
 736   2              if (is_pwr_down) // ç¼“æ…¢å‡é™
 737   2                  c_duty += 1;
 738   2              else
 739   2                  c_duty += 10;
 740   2          }
 741   1      
 742   1          if (c_duty >= pwm_in_duty)
 743   1          {
 744   2              c_duty = pwm_in_duty;
 745   2              led_state = LED_NULL;
 746   2              gamma = c_duty;
 747   2              is_pwr_down = 0; // å®Œæˆç¼“æ…¢å‡é™
 748   2          }
 749   1          set_pwm_duty();
 750   1      }
 751          
 752          void led_sub(void)
 753          {
 754   1          if (led_state != LED_ADJ_S)
 755   1              return;
 756   1      
 757   1          if (c_duty > pwm_in_duty)
 758   1          {
 759   2              if (is_pwr_down)
 760   2                  c_duty -= 1;
 761   2              else
 762   2              {
 763   3                  if (c_duty > 50)
 764   3                  {
 765   4      
 766   4                      c_duty -= 10;
 767   4                  }
 768   3                  else
 769   3                  {
 770   4                      c_duty -= 1;
 771   4                  }
 772   3              }
 773   2          }
 774   1          if (c_duty <= pwm_in_duty)
 775   1          {
 776   2              c_duty = pwm_in_duty;
 777   2              gamma = c_duty;
 778   2              is_pwr_down = 0; // å®Œæˆç¼“æ…¢å‡é™
 779   2              led_state = LED_NULL;
 780   2          }
 781   1          set_pwm_duty();
 782   1      }
 783          
 784          // æœ‰æ²¡æœ‰é™åŠŸç‡
 785          #define LOW_PWR_R7 P00
 786          // æœ‰æ²¡æœ‰ä¸‰åˆä¸€
C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 14  

 787          #define _3_1_R14 P02
 788          // æœ‰æ²¡æœ‰æ—¶ç©º
 789          #define T_C_R11 P03
 790          
 791          #define T_C_R8 P13
 792          #define T_C_R9 P12
 793          #define T_C_R10 P11
 794          
 795          // é™åŠŸç‡ã€æ—¶ç©ºã€ä¸‰åˆä¸€åŠŸèƒ½
 796          void option_fun(void)
 797          {
 798   1          flag_init();
 799   1          // p13è¾“å…¥ä¸Šæ‹‰ï¼Œæ—¶ç©ºç»„åˆR8
 800   1          P1_MD0 &= ~(GPIO_P13_MODE_SEL(0x3));
 801   1          P1_PU |= (GPIO_P13_PULL_UP(0x1));
 802   1          P1_PD |= (GPIO_P13_PULL_PD(1));
 803   1          //   æ—¶ç©ºç»„åˆR9
 804   1          P1_MD0 &= ~(GPIO_P12_MODE_SEL(0x3));
 805   1          P1_PU |= (GPIO_P12_PULL_UP(0x1));
 806   1          // æ—¶ç©ºç»„åˆR10
 807   1          P1_MD0 &= ~(GPIO_P11_MODE_SEL(0x3));
 808   1          P1_PU |= (GPIO_P11_PULL_UP(0x1));
 809   1          // é™åŠŸç‡æœ‰/æ—  R7
 810   1          P0_MD0 &= ~(GPIO_P00_MODE_SEL(0x3));
 811   1          P0_PU |= (GPIO_P00_PULL_UP(0x1));
 812   1          // ä¸‰åˆä¸€æœ‰/æ—  R14
 813   1          P0_MD0 &= ~(GPIO_P02_MODE_SEL(0x3));
 814   1          P0_PU |= (GPIO_P02_PULL_UP(0x1));
 815   1          // æ—¶ç©ºæœ‰/æ—  R11
 816   1          P0_MD0 &= ~(GPIO_P03_MODE_SEL(0x3));
 817   1          P0_PU |= (GPIO_P03_PULL_UP(0x1));
 818   1      
 819   1          if (LOW_PWR_R7 == 0) // ä½ç”µå¹³æœ‰é™åŠŸç‡
 820   1          {
 821   2              l_pwr.en = 1;
 822   2              printf("l_pwr.en = 1\r\n");
 823   2          }
 824   1          else
 825   1          {
 826   2              l_pwr.en = 0;
 827   2              printf("l_pwr.en = 0\r\n");
 828   2          }
 829   1          if (adc0_val > 4000) // LIN æ”¹ åŠ å…¥äº†ntcå’Œç”µä½å™¨ADå€¼çš„åˆ¤æ–­ ntcå’Œç”µä½å™¨éƒ½ä¸Šæ‹‰
 830   1          {
 831   2              ex_temp_en = 0;
 832   2              printf("ex_temp_en = 0\r\n");
 833   2          }
 834   1          else
 835   1          {
 836   2              ex_temp_en = 1;
 837   2              printf("ex_temp_en = 1\r\n");
 838   2          }
 839   1          if (adc1_val > 4000)
 840   1          {
 841   2              adjust_en = 0;
 842   2              printf("adjust_en = 0\r\n");
 843   2          }
 844   1          else
 845   1          {
 846   2              adjust_en = 1;
 847   2              printf("adjust_en = 1\r\n");
 848   2          }
C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 15  

 849   1          if (_3_1_R14 == 1) // é«˜ç”µå¹³æœ‰ä¸‰åˆä¸€
 850   1          {
 851   2              _3_1.en = 1;
 852   2              // simple_over = 1;
 853   2              printf("_3_1.en  = 1\r\n");
 854   2          }
 855   1          else
 856   1          {
 857   2              _3_1.en = 0;
 858   2              simple_over = 1;
 859   2              printf("_3_1.en  = 0\r\n");
 860   2          }
 861   1      
 862   1          // ä½ç”µå¹³æ—¶ç©º
 863   1          if (T_C_R11 == 0) //  0
 864   1          {
 865   2              t_ctrl.en = 1;
 866   2              printf("t_ctrl.en = 1\r\n");
 867   2          }
 868   1          else
 869   1          {
 870   2              t_ctrl.en = 0;
 871   2              printf("t_ctrl.en = 0\r\n");
 872   2          }
 873   1      
 874   1          // æ—¶æ§æ¨¡å¼0ï¼š100%6H 50%6H 0%
 875   1          // æ—¶æ§æ¨¡å¼1ï¼š100%4H 50%8H 0%
 876   1          // æ—¶æ§æ¨¡å¼2ï¼š100%5H 70%3H 50%4H 0%
 877   1          // æ—¶æ§æ¨¡å¼3ï¼š100%4H 70%4H 50%4H 0%
 878   1          // æ—¶æ§æ¨¡å¼4ï¼š100%4H 60%2H 30%3H 60%2H 100%1H 0%
 879   1      
 880   1          if (T_C_R8 == 1 && T_C_R9 == 1 && T_C_R10 == 1)
 881   1          {
 882   2              t_ctrl.list = 0;
 883   2              p_list = &t_ctrl_lis_0;
 884   2              printf("t_ctrl.list = 0 \r\n");
 885   2          }
 886   1          else if (T_C_R8 == 0 && T_C_R9 == 1 && T_C_R10 == 1)
 887   1          {
 888   2              t_ctrl.list = 1;
 889   2              p_list = &t_ctrl_lis_1;
 890   2              printf("t_ctrl.list = 1\r\n ");
 891   2          }
 892   1          else if (T_C_R8 == 1 && T_C_R9 == 0 && T_C_R10 == 1)
 893   1          {
 894   2              t_ctrl.list = 2;
 895   2              p_list = &t_ctrl_lis_2;
 896   2              printf("t_ctrl.list = 2\r\n ");
 897   2          }
 898   1          else if (T_C_R8 == 1 && T_C_R9 == 1 && T_C_R10 == 0)
 899   1          {
 900   2              t_ctrl.list = 3;
 901   2              p_list = &t_ctrl_lis_3;
 902   2              printf("t_ctrl.list = 3\r\n ");
 903   2          }
 904   1          else if (T_C_R8 == 0 && T_C_R9 == 0 && T_C_R10 == 1)
 905   1          {
 906   2              t_ctrl.list = 4;
 907   2              p_list = &t_ctrl_lis_4;
 908   2              printf("t_ctrl.list = 4\r\n");
 909   2          }
 910   1      }
C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 16  

 911          
 912          // é™åŠŸç‡è®¡æ—¶å¤„ç†
 913          void l_pwr_timer_handler(void)
 914          {
 915   1          if (l_pwr.en == 1)
 916   1          {
 917   2              if (l_pwr.t < L_PWR_T) // å°æ—¶
 918   2              {
 919   3                  l_pwr.t++;
 920   3              }
 921   2              else
 922   2              {
 923   3                  extemp_tctrl_flag = 1;
 924   3                  if (adjust_en == 1) // ç”µä½å™¨ä½¿èƒ½
 925   3                  {
 926   4                      if (_3_1.en == 1) // æœ‰ä¸‰åˆä¸€åŠŸèƒ½å’Œç”µä½å™¨
 927   4                      {
 928   5                          // åˆ¤æ–­PWM_inå ç©ºæ¯”å¤§äº74
 929   5                          if (pwm_in_duty_xuwei > ajust_duty / 100 * 75) // LIN æ”¹  75%æ”¹æˆç”µä½å™¨çš„75%
 930   5                          {
 931   6                              max_duty = ajust_duty / 100 * 75;
 932   6                              l_pwr.act = 1; // é™åŠŸç‡çŠ¶æ€
 933   6                              l_pwr.en = 0;  // å¤„ç†å®Œæˆï¼Œä½¿èƒ½é™åŠŸç‡
 934   6                              is_pwr_down = 1;
 935   6                          }
 936   5                      }
 937   4                      else
 938   4                      {
 939   5                          max_duty = ajust_duty / 100 * 75;
 940   5                          l_pwr.act = 1; // é™åŠŸç‡çŠ¶æ€
 941   5                          l_pwr.en = 0;  // å¤„ç†å®Œæˆï¼Œä½¿èƒ½é™åŠŸç‡
 942   5                          is_pwr_down = 1;
 943   5                      }
 944   4                  }
 945   3      
 946   3                  if (adjust_en == 0) // æ— ç”µä½å™¨
 947   3                  {
 948   4                      if (_3_1.en) // æœ‰ä¸‰åˆä¸€åŠŸèƒ½
 949   4                      {
 950   5                          // åˆ¤æ–­PWM_inå ç©ºæ¯”å¤§äº74
 951   5                          if (pwm_in_duty > _75_DUTY)
 952   5                          {
 953   6                              max_duty = _75_DUTY;
 954   6                              l_pwr.act = 1; // é™åŠŸç‡çŠ¶æ€
 955   6                              l_pwr.en = 0;  // å¤„ç†å®Œæˆï¼Œä½¿èƒ½é™åŠŸç‡
 956   6                              is_pwr_down = 1;
 957   6                          }
 958   5                      }
 959   4                      else
 960   4                      {
 961   5                          max_duty = _75_DUTY;
 962   5                          l_pwr.act = 1; // é™åŠŸç‡çŠ¶æ€
 963   5                          l_pwr.en = 0;  // å¤„ç†å®Œæˆï¼Œä½¿èƒ½é™åŠŸç‡
 964   5                          is_pwr_down = 1;
 965   5                      }
 966   4                  }
 967   3                  l_pwr.en = 0;
 968   3                  ex_max_duty = max_duty;
 969   3              }
 970   2          }
 971   1      }
 972          
C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 17  

 973          // å¤„ç†é™åŠŸç‡ï¼Œæ—¶æ§æ—¶ï¼Œå¯è°ƒçš„å ç©ºæ¯”èŒƒå›´
 974          // å»¶æ—¶å¼€æœºæ¨¡å¼ï¼Œå¼ºåˆ¶pwm_in_duty=0
 975          void pwm_in_handler(void)
 976          {
 977   1          // if(_3_1.en)     //æœ‰ä¸‰åˆä¸€åŠŸèƒ½
 978   1          {
 979   2              // æ—¶æ§å’Œé™åŠŸç‡æ¿€æ´»çŠ¶æ€ï¼Œæœ€å¤§å ç©ºæ¯”ä¸è¶…è¿‡é™åŠŸç‡ï¼Œæ—¶æ§, LIN æ”¹ è¿‡æ¸©é™å
             -ŠŸç‡è®¾å®šçš„å ç©ºæ¯”
 980   2              //                      if(t_ctrl.en == 1)
 981   2              //                      {
 982   2              //                              if(_3_1.en==1)
 983   2              //                {
 984   2              //                    pwm_in_duty = pwm_in_duty;
 985   2              //                }
 986   2              //
 987   2              //                              if(adjust_en==1)
 988   2              //                              {
 989   2              //                                      pwm_in_duty = ajust_duty;
 990   2              //                              }
 991   2              //                              if(_3_1.en==0&&adjust_en==0)
 992   2              //                              {
 993   2              //                                      pwm_in_duty = max_duty;
 994   2              //                              }
 995   2              //                      }
 996   2              if (t_ctrl.en == 0 && adjust_en == 1)
 997   2              {
 998   3                  if (_3_1.en == 1)
 999   3                  {
1000   4                      pwm_in_duty = pwm_in_duty_xuwei;
1001   4                  }
1002   3                  else
1003   3                  {
1004   4                      pwm_in_duty = ajust_duty;
1005   4                  }
1006   3              }
1007   2              if (l_pwr.act == 1 || t_ctrl.en == 1)
1008   2              {
1009   3                  // è¿›å…¥é™åŠŸç‡æ¨¡å¼
1010   3      
1011   3                  if (adjust_en == 1 && _3_1.en == 1)
1012   3                  {
1013   4      
1014   4                      if (pwm_in_duty_xuwei > max_duty)
1015   4                      {
1016   5                          pwm_in_duty_xuwei = max_duty;
1017   5                      }
1018   4                      pwm_in_duty = pwm_in_duty_xuwei;
1019   4                  }
1020   3                  else
1021   3                  {
1022   4                      if (pwm_in_duty > max_duty)
1023   4                      {
1024   5                          pwm_in_duty = max_duty;
1025   5                      }
1026   4                  }
1027   3              }
1028   2              if (ex_temp_en == 1 && t_ctrl.en == 0)
1029   2              {
1030   3                  if (adjust_en == 0 && _3_1.en == 0)
1031   3                  {
1032   4                      pwm_in_duty = max_duty;
1033   4                  }
C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 18  

1034   3                  if (pwm_in_duty > max_duty)
1035   3                  {
1036   4                      pwm_in_duty = max_duty;
1037   4                  }
1038   3                  if (max_duty == 0)
1039   3                  {
1040   4                      pwm_in_duty = 0;
1041   4                  }
1042   3              }
1043   2          }
1044   1          // is_pwr_down=0;
1045   1          //    if(dly_pwr_on == 1)
1046   1          //    {
1047   1          //        // å»¶æ—¶å¯åŠ¨ï¼Œå¼ºåˆ¶pwm 0
1048   1          //        pwm_in_duty = 0;
1049   1          //    }
1050   1      }
1051          
1052          // 1sè°ƒç”¨ä¸€æ¬¡
1053          void t_ctrl_timer_handler(void)
1054          {
1055   1          if (t_ctrl.en == 1)
1056   1      
1057   1          {
1058   2              // å½“å‰åˆ—è¡¨æ—¶é—´é255ï¼Œå¦‚æœæ˜¯255åˆ™è¯´æ˜æ—¶ç©ºç»“æŸ
1059   2              if (p_list[t_ctrl.level].t != 255)
1060   2              {
1061   3                  //                  t_ctrl.list = 4;
1062   3                  //        p_list = &t_ctrl_lis_4;
1063   3                  t_ctrl.t++;
1064   3                  if (t_ctrl.t >= (p_list[t_ctrl.level].t * 60 * 60)) // æ”¹æˆ10s
1065   3                  // if(t_ctrl.t >= (p_list[t_ctrl.level].t * 10) )
1066   3                  {
1067   4                      t_ctrl.level++;
1068   4                      is_pwr_down = 1;
1069   4                      t_ctrl.t = 0;
1070   4                      max_duty = p_list[t_ctrl.level].b;
1071   4                      extemp_tctrl_flag = 1;
1072   4                      if (adjust_en == 1) // LIN æ”¹ åŠ å…¥ç”µä½å™¨æ—¶ å°†æœ€å¤§å€¼å˜æˆç”µä½å™¨çš„æœ€å¤§å€¼
1073   4                      {
1074   5                          switch (max_duty)
1075   5                          {
1076   6                          case 6000:
1077   6                              max_duty = ajust_duty;
1078   6                              break;
1079   6                          case 4200:
1080   6                              max_duty = ajust_duty / 10 * 7;
1081   6                              break;
1082   6                          case 3600:
1083   6                              max_duty = ajust_duty / 10 * 6;
1084   6                              break;
1085   6                          case 3000:
1086   6                              max_duty = ajust_duty / 2;
1087   6                              break;
1088   6                          case 1800:
1089   6                              max_duty = ajust_duty / 10 * 3;
1090   6                              break;
1091   6                          default:
1092   6                              break;
1093   6                          }
1094   5                      }
1095   4                      if (_3_1.en == 1 && ex_temp_en == 1 && t_ctrl.en == 0)
C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 19  

1096   4                      {
1097   5                          //  if(adjust_en==0)
1098   5                          {
1099   6                              if (ex_pwm_in_duty < max_duty)
1100   6                              {
1101   7                                  max_duty = ex_pwm_in_duty;
1102   7                              }
1103   6                          }
1104   5                          //                                                          else
1105   5                          //                                                          {
1106   5                          //                                                                  if(pwm_in_duty_xuwei<max_duty)
1107   5                          //                                                                  {
1108   5                          //                                                                          max_duty=pwm_in_duty_xuwei;
1109   5                          //                                                                  }
1110   5                          //                                                          }
1111   5                      }
1112   4                      pwm_in_duty = max_duty; // ä¿®å¤t_ctrl_lis_4ï¼ŒåŠŸç‡é™åˆ°30%å‡ä¸äº†60%
1113   4                      if (adjust_en == 1 && _3_1.en == 1)
1114   4                      {
1115   5                          pwm_in_duty_xuwei = max_duty;
1116   5                      }
1117   4                  }
1118   3              }
1119   2      
1120   2              //                              if(p_list[t_ctrl.level].t != 0)
1121   2              //                              {
1122   2              //                                      t_ctrl.level=0;
1123   2              //                              }
1124   2              // is_pwr_dow=0;
1125   2          }
1126   1          // printf("pwm_in_duty= %d  t= %d  ajust_duty=%d  max_duty=%d adjust_val=%d pwm_save[0]=%d\r\n", (int)
             -pwm_in_duty,(int)t_ctrl.t,(int)ajust_duty,(int)c_duty,(int)adjust_val,(int)pwm_save[0]);
1127   1          // printf("pwm_in_duty= %d   t= %d    t_ctrl.level=%d    c_duty=%d\r\n", (int)pwm_in_duty,(int)t_ctrl.
             -t,(int)ajust_duty,(int)c_duty);
1128   1      }
1129          
1130          // 1ç§’è°ƒç”¨ä¸€æ¬¡
1131          extern u8 lvd_mode;
1132          extern volatile u8 lvd_flag;
1133          void dly_pwr_on_handler(void)
1134          {
1135   1          if (dly_pwr_on == 1) // å»¶æ—¶å¯åŠ¨
1136   1          {
1137   2              user_printf("lvd pwr low \n");
1138   2              dly_pwr_on_cnt++;
1139   2              if (dly_pwr_on_cnt >= 5)
1140   2              {
1141   3                  lvd_flag = 0;
1142   3                  dly_pwr_on_cnt = 0;
1143   3      
1144   3                  dly_pwr_on = 0;
1145   3      
1146   3                  c_duty = 0;
1147   3                  max_duty = MAX_DUTY;
1148   3      
1149   3                  t_ctrl.list = 0;
1150   3                  t_ctrl.t = 0;
1151   3                  t_ctrl.en = 0;
1152   3                  t_ctrl.level = 0;
1153   3      
1154   3                  l_pwr.en = 0;
1155   3                  l_pwr.act = 0;
C51 COMPILER V9.60.7.0   LED_CTRL                                                          09/08/2025 11:56:55 PAGE 20  

1156   3                  l_pwr.t = 0;
1157   3      
1158   3                  _3_1.en = 0;
1159   3                  pwm_in_duty = 0;
1160   3                  ex_temp_en = 0;
1161   3                  adjust_en = 0;
1162   3                  gamma = 2;
1163   3                  option_fun();
1164   3      
1165   3                  led_state = LED_PWR_ON;
1166   3                  printf("LED_PWR_ON");
1167   3              }
1168   2          }
1169   1      }
1170          void flag_init()
1171          {
1172   1          lvd_flag = 0;
1173   1          dly_pwr_on_cnt = 0;
1174   1      
1175   1          dly_pwr_on = 0;
1176   1      
1177   1          c_duty = 0;
1178   1          max_duty = MAX_DUTY;
1179   1      
1180   1          t_ctrl.list = 0;
1181   1          t_ctrl.t = 0;
1182   1          t_ctrl.en = 0;
1183   1          t_ctrl.level = 0;
1184   1      
1185   1          l_pwr.en = 0;
1186   1          l_pwr.act = 0;
1187   1          l_pwr.t = 0;
1188   1      
1189   1          _3_1.en = 0;
1190   1          pwm_in_duty = 0;
1191   1          ex_temp_en = 0;
1192   1          adjust_en = 0;
1193   1          gamma = 2;
1194   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3586    ----
   CONSTANT SIZE    =    328    ----
   XDATA SIZE       =    112       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      6    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
